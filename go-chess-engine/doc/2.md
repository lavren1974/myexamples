Конечно. Вот вторая статья из серии, посвящённая тому, как оживить движок с помощью UCI и объяснить ему истинное значение разрешённого приёма.

---

## Часть 2: Разговариваем на языке шахмат — UCI и законность

В части 1 мы создали теоретическую основу нашего шахматного движка: цифровое представление доски и полное понимание того, как двигается каждая фигура. Однако этот «мозг» существует в вакууме. Он не может получать инструкции, объявлять свои ходы или каким-либо образом взаимодействовать с пользователем. Более того, хотя он знает, как двигается фигура,можетход, он еще не понимает самого главного правила в шахматах:**вы не можете сделать ход, который оставит вашего короля под шахом.**

В этой статье мы решим обе проблемы. Сначала мы дадим нашему движку голос, реализовав протокол универсального шахматного интерфейса (UCI), а затем дадим ему разум, обучив его правилам шаха, мата и пата.

### Даем движку голос: универсальный шахматный интерфейс (UCI)

Вместо того, чтобы разрабатывать собственный графический пользовательский интерфейс (GUI), мы можем использовать десятки уже существующих отличных бесплатных шахматных GUI (например, Arena, Cute Chess или WinBoard). Для этого наш движок должен понимать их язык. Отраслевым стандартом для этого является универсальный шахматный интерфейс (UCI) — простой текстовый протокол.

Движок считывает команды из стандартного ввода (стандартный ввод) и выводит свои ответы на стандартный вывод (стандартный вывод). Весь «диалог» между графическим интерфейсом и движком — это просто последовательность текстовых строк.

Наша реализация представляет собой основной цикл, который прослушивает эти команды и отправляет их соответствующему обработчику.

codeИдти

```
// From uci/uci.go (simplified)
func (h *Handler) Loop() {
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		command := scanner.Text()
		fields := strings.Fields(command)

		switch fields[0] {
		case "uci":
			// The GUI asks if we support the UCI protocol.
			h.handleUci() 
		case "isready":
			// The GUI asks if we are ready to receive more commands.
			h.handleIsReady()
		case "position":
			// The GUI gives us the current board state.
			h.handlePosition(fields)
		case "go":
			// The GUI tells us to start thinking and find the best move.
			h.handleGo()
		case "quit":
			// The GUI tells us to shut down.
			return
		}
	}
}
```

Наиболее важные команды:

- позиция [фен ... | startpos] перемещает e2e4 e7e5 ...Эта команда — способ графического интерфейса сообщить нашему движку точное состояние платы. Она может либо предоставить строку FEN для пользовательской позиции, либо начать с начала (стартпос) и затем перечислите все сделанные на данный момент ходы (например,е2е4,g8f6). Наш движок должен проанализировать эту строку и обновить свою внутреннюю плату для соответствия.
    
- go wtime 300000 btime 300000 ...Это команда «начать думать». Графический интерфейс показывает нам, сколько времени осталось у каждого игрока, а задача нашего движка — найти лучший ход и вывести его на стандартный вывод в формателучший ход e1g1.
    

**Примечание по отладке:**Взаимодействие с графическим интерфейсом может быть сложным. Самый важный инструмент на этом этапе — файл журнала. Каждая полученная команда и каждый отправленный ответ должны быть записаны в текстовый файл, создавая расшифровку разговора, которая бесценна для поиска ошибок.

### От псевдолегального к легальному: закон короля

Наш движок теперь может общаться, но он всё ещё наивен. Он понимает, что ладья ходит по прямой, но не понимает, что ладья, прикованная к королю,не можетВ этом и заключается разница между**псевдолегальный**двигаться и действительно**юридический**двигаться.

Алгоритм фильтрации разрешенных ходов прост по своей концепции, но эффект его глубок:

> Для каждого псевдолегального хода временно сделайте его на копии доски, а затем задайте один вопрос: «Мой король сейчас под атакой?» Если ответ «нет», ход легален.

Эта элегантная логика решает любую ситуацию:

- Он не позволяет королю занять атакуемое поле.
    
- Это позволяет фигуре блокировать атаку, перемещаясь между атакующим и королем.
    
- Позволяет фигуре захватить атакующего.
    
- Это не позволяет связанной фигуре двигаться и обнажать своего короля.
    

Для реализации этого нам понадобится краеугольная функция:isSquareAttackedЭта функция принимает поле и цвет атакующего и определяет, атакует ли его какая-либо фигура этого цвета. По сути, она осуществляет обратную разработку атаки, отслеживая от целевого поля наличие вражеских пешек, коней, королей или скользящих фигур.

С помощью этой вспомогательной функции наш новыйGenerateLegalMovesфункция становится мозгом операции:

codeИдти

```
// From chess/arrayboard.go (conceptual)
func (b *ArrayBoard) GenerateLegalMoves() []Move {
	var legalMoves []Move
	pseudoLegalMoves := b.generatePseudoLegalMoves() // The generator from Part 1

	for _, move := range pseudoLegalMoves {
		// Create a temporary "what if" scenario
		tempBoard := *b 
		tempBoard.ApplyMove(move)

		// Find our king on this new temporary board
		kingSquare := tempBoard.findMyKing()

		// Ask the critical question
		if !tempBoard.isSquareAttacked(kingSquare, opponentColor) {
			// If the king is safe, the move was legal!
			legalMoves = append(legalMoves, move)
		}
	}
	return legalMoves
}
```

### Расплата: шах и мат бесплатно

Прелесть этого алгоритма в том, что он позволяет нам автоматически определить конец игры.GenerateLegalMovesзавершено, можем проверить результат:

- **Если список допустимых ходов пуст И наш король в данный момент находится под шахом**, это означает, что нет возможности спасти короля. Это**шах и мат**.
    
- **Если список допустимых ходов пуст И наш король в данный момент НЕ находится под шахом**, это значит, что у нас нет хода, но нас не атакуют. Это**патовая ситуация**.
    

Нам не нужно писать отдельную сложную логику для обнаружения этих условий окончания игры; они являются возникающим свойством нашего генератора допустимых ходов.

### Заключение части 2

Наш движок совершил огромный скачок вперёд. Он превратился из теоретической модели в практическую, строго определённую программу. Теперь его можно загрузить в любой стандартный шахматный графический интерфейс, и он сыграет полную, легальную шахматную партию от начала до конца, правильно определяя маты и паты.

Однако игра в неё ужасна, ходы выбираются случайным образом. А на современных компьютерах она кажется вялой, поскольку её поле, основанное на массивах, требует циклов для поиска всех элементов. В следующей части мы решим эту проблему напрямую, перестроив архитектуру нашего движка ради чистой скорости с помощью битбордов.