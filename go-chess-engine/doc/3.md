Конечно. Представляем третью статью из серии, посвящённую архитектурному переходу на битовые платы для повышения производительности.

---

## Часть 3: Жажда скорости — революция на битбордах

В первых двух частях нашей серии мы создали шахматный движок, который, прежде всего,правильныйОн понимает все правила шахмат, безупречно взаимодействует с помощью протокола UCI и может сыграть полную, легальную партию. Однако он также медленный. Его мозг, использующий простой массив для представления доски, должен использоватьдляЦиклы для последовательного обхода клеток, поиска фигур и расчета ходов. Мощный шахматный движок должен обдумывать миллионы позиций в секунду, чего наша текущая разработка никогда не сможет достичь.

В этой статье мы проведем самый важный рефакторинг производительности в жизни движка: переход к**битборды**. Это не только сделает наш движок на порядок быстрее, но и станет мастер-классом по архитектуре программного обеспечения, научив нас поддерживать несколько сложных систем в рамках единого, понятного интерфейса.

### Что такое битборд?

Битборд — это 64-битное беззнаковое целое число (uint64в Го), где каждый из 64 битов соответствует одной клетке на шахматной доске.1на бите означает, что фигура находится на этом поле;0означает, что он пуст.

Вместо одной платы, движок для битборда использует несколько. У нас есть отдельная плата для каждого типа детали и цвета. Например,whitePawnsBBэтоuint64где биты набора представляют расположение всех белых пешек. У нас также есть битборды для заполнения, напримерwhitePiecesBB,blackPiecesBB, иallPiecesBB.

Магия битбордов заключается в их скорости. Современный процессор предназначен для выполнения побитовых операций (И).&, ИЛИ|, XOR^, СДВИГ<< >>) на всех 64 битах за один такт. Вместо цикла мы можем задавать вопросы всей плате одновременно.

- Хотите найти все пустые квадраты?пустойBB := ^allPiecesBB
    
- Хотите найти все белые пешки, которые могут быть взяты черными фигурами?уязвимыеПешкиBB := белыеПешкиBB и черныеАтакиBB
    

Это основа высокоскоростного генератора ходов.

### Архитектурная задача: поддержка двух систем

Переписывание нашего движка для использования битбордов — это колоссальная задача. Если мы просто удалим старый код, основанный на массивах, мы потеряем ценный ресурс: простую, корректную и легко отлаживаемую модель. Лучший путь — поддерживатьобапредставления.

Чтобы добиться этого, мы используем одну из самых мощных функций Go:**интерфейсы**. Сначала мы определим, что такоеДоска являетсяпо его поведению:

codeИдти

````
// From chess/board.go
package chess

type Board interface {
	ApplyMove(m Move)
	GenerateLegalMoves() []Move
	SideToMove() Color
	IsCheckmate() bool
	IsStalemate() bool
}
```This interface makes a contract: any data type that provides these five methods can be considered a `Board`. Now, we can refactor our existing `ArrayBoard` and create our new `Bitboard` struct, ensuring both of them satisfy this interface.

Our engine's UCI handler and "thinking" components no longer care about the underlying implementation. They are simply given a `chess.Board` and can trust that it knows how to generate legal moves and apply them.

```go
// From uci/uci.go
type Handler struct {
	board  chess.Board // This is the INTERFACE, not a specific type
	engine *engine.Engine
}

// From engine/engine.go
func (e *Engine) FindBestMove(b chess.Board) chess.Move {
	// This code works for both ArrayBoard and Bitboard without any changes!
	moves := b.GenerateLegalMoves() 
	// ...
}
````

Для переключения между ними мы вводим простоеconfig.jsonФайл и «фабричная» функция, которая считывает этот файл при запуске и конструирует запрошенный тип платы. Это даёт нам максимальную гибкость: мы можем протестировать наш быстрый движок битборда и, если обнаружим ошибку, вернуться к простой плате массива, чтобы диагностировать проблему с помощью более чёткой модели.

### Реализация генерации Bitboard Move

Генерация ходов с помощью битбордов — это совершенно другая парадигма. Вместо того, чтобы циклически обходить клетки, мы работаем сразу с целыми наборами фигур.

Давайте рассмотрим генерацию одиночных толчков для всех белых пешек:

1. ВозьмиwhitePawnsBB.
    
2. **Сдвиг**вся битовая панель "Север" на 8 бит:pushes := whitePawnsBB << 8. Это одновременно перемещает все пешки вперед на одну клетку.
    
3. Найдите все пустые клетки на доске:emptySquaresBB := ^allPiecesBB.
    
4. Использовать побитовое**И**чтобы найти только те толчки, которые приземляются на пустую клетку:legalPushesBB := pushes & emptySquaresBB.
    

Всего за три операции процессора мы нашли все возможные варианты продвижения одной пешки на доске. Затем мы используем вспомогательную функцию, называемуюlsb(младший бит), чтобы найти индекс каждого заданного бита в результате и преобразовать их вДвигатьсяструктуры.

Эта же философия применима ко всем фигурам. Ходы коня можно получить, передвигаярыцариBBв восьми различных направлениях. Перемещение фигур — наиболее сложный процесс, часто требующий продвинутых техник, таких как «Magic Bitboards», для максимальной производительности, но даже более простой подход с циклами по битбордам значительно быстрее метода массива.

### Заключение части 3

Наш движок претерпел радикальные изменения. Хотя внешне он остался прежним — он по-прежнему играет в легальные случайные шахматы, — его внутреннее сердце теперь представляет собой высокопроизводительную машину. Мы успешно реализовали генератор ходов на основе битовой платы, который на порядок быстрее нашей первоначальной разработки.

Что ещё важнее, нам удалось сделать это без ущерба для стабильности и отлаживаемости, используя интерфейсы для создания гибкой архитектуры, поддерживающей как нашу простую модель, так и сложную, высокоскоростную. Движок теперь действительно «быстрый». В заключительной части нашей серии мы рассмотрим, как сделать его «умным», познакомив вас с концепциями оценки и поиска.